
---
# Front matter
lang: ru-RU
title: "Лабораторная работа № 2"
subtitle: "Управление версиями"
author: "Маметкадыров Ынтымак"

# Formatting
toc_depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4paper
documentclass: scrreprt
polyglossia-lang: russian
polyglossia-otherlangs: english
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase
indent: true
pdf-engine: lualatex
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Изучить идеологию и применение средств контроля версий.

# Задание

– Сделайте отчёт по предыдущей лабораторной работе в формате Markdown.
– В качестве отчёта просьба предоставить отчёты в 3 форматах: pdf, docx и md (в
архиве, поскольку он должен содержать скриншоты, Makefile и т.д.)

# Выполнение лабораторной работы

1. Создали учётную запись на https://github.com. (рис. 1)

![Рис. 1. Учетная запись GitHub](/home/itmametkadihrov/SCR/1.JPG){ #fig:001 width=70% }

2. Сначала сделаем предварительную конфигурацию, указав имя и email владельца репозитория: (рис. 2)

![Рис. 2. Предварительная конфигурация](/home/itmametkadihrov/SCR/2.JPG){ #fig:001 width=70% }

3. Создали репозиторий с именем os-intro. (рис. 3)

![Рис. 3. Репозиторий os-intro](/home/itmametkadihrov/SCR/3.JPG){ #fig:001 width=70% }

4. Инициализировали системы git командой get init.

5. Создали заготовку для файла README.md (рис. 4)

![Рис. 4. Создание заготовки](/home/itmametkadihrov/SCR/4.JPG){ #fig:001 width=70% }

6. Добавили файл лицензии: (рис. 5)

![Рис. 5. Лицензия](/home/itmametkadihrov/SCR/5.JPG){ #fig:001 width=70% }

7. Добавили шаблон игнорируемых файлов. Просмотрели список имеющихся шаблонов (рис. 6)

![Рис. 6. Добавление шаблона](/home/itmametkadihrov/SCR/6.JPG){ #fig:001 width=70% }

8. Затем скачали шаблон для C (рис. 7)

![Рис. 7. Скачивание шаблона](/home/itmametkadihrov/SCR/7.JPG){ #fig:001 width=70% }

9. Добавили новые файлы: git add .

10. Выполнили коммит: git commit -a

11. Отправили на github: git oush

12. Инициализировали git-flow: git flow init

13. Проверили что мы на ветке develop: git branch

14. Создали релиз с версией 1.0.0, записали версию, добавили индекс (рис. 8).
 
![Рис. 8. Создание релиза](/home/itmametkadihrov/SCR/8.JPG){ #fig:001 width=70% }

15. Залили релизную ветку в основную ветку командой: git flow release finish 1.0.0.

16. Отправили данные на github (рис. 9)

![Рис. 9. Отправка на github](/home/itmametkadihrov/SCR/9.JPG){ #fig:001 width=70% }

# Выводы

Изучили идеологию и применение средств контроля версий.

# Контрольные вопросы

1.	Системы контроля версий - это программы которые позволяют отслеживать изменения вашего файла, и хранить их. Системы контроля версий применяются при работе нескольких человек над одним проектом. Обычно основное дерево проекта хранится в локальном или удалённом репозитории, к которому настроен доступ для участников проекта. При внесении изменений в содержание проекта система контроля версий позволяет их фиксировать, совмещать изменения, произведённые разными участниками проекта, производить откат к любой более ранней версии проекта, если это требуется.

2.	Хранилище — это содержимое скрытой папки .git. В этой папке хранятся все версии рабочей области и служебная информация.
Коммит – сохранение, фиксация изменений в программном коде.
Рабочая копия — текущее состояние файлов проекта (любой версии), полученных из хранилища и, возможно, измененных.

3.	Традиционные системы управления версиями используют централизованную модель (рис. 10), когда имеется единое хранилище документов, управляемое специальным сервером, который и выполняет бо́льшую часть функций по управлению версиями. Пользователь, работающий с документами, должен сначала получить нужную ему версию документа из хранилища; обычно создаётся локальная копия документа, так называемая «рабочая копия». Может быть получена последняя версия или любая из предыдущих, которая может быть выбрана по номеру версии или дате создания, иногда и по другим признакам. После того, как в документ внесены нужные изменения, новая версия помещается в хранилище. В отличие от простого сохранения файла, предыдущая версия не стирается, а тоже остаётся в хранилище и может быть оттуда получена в любое время. копия - копия проекта, связанная с репозиторием.

![Рис. 10. Централизованная модель VCS](/home/itmametkadihrov/SCR/10.JPG){ #fig:001 width=70% }

Децентрализованная (DVCS) (рис. 11) система означает, что у каждого разработчика есть личный репозиторий проекта с полным набором всех версий. А все необходимые для работы файлы находятся на компьютере. При этом постоянное подключение к сети не требуется, поэтому система работает быстро. При командной разработке нужна синхронизация репозиториев, так как проект — один и его состояние должно быть у всех одинаковым.

![Рис. 11. Децентрализованная модель VCS](/home/itmametkadihrov/SCR/11.JPG){ #fig:001 width=70% }
 
Две наиболее известные DVCS – это Git и Mercurial.
В качестве примеров централизованных VCS можно привести CVS, Subversion.

4.	Первым действием, которое должен выполнить разработчик, является извлечение рабочей копии проекта или той его части, с которой предстоит работать. Это действие выполняется с помощью команды извлечения версии (обычно checkout или clone). Разработчик задаёт версию, которая должна быть скопирована, по умолчанию обычно копируется последняя (или выбранная администратором в качестве основной) версия.( рис. 12)
 
![Рис. 12. Единоличная работа с VCS](/home/itmametkadihrov/SCR/12.JPG){ #fig:001 width=70% }

5.	По команде извлечения устанавливается соединение с сервером, и проект (или его часть — один из каталогов с подкаталогами) в виде дерева каталогов и файлов копируется на компьютер разработчика. Обычной практикой является дублирование рабочей копии: помимо основного каталога с проектом на локальный диск (либо в отдельный, специально выбранный каталог, либо в системные подкаталоги основного дерева проекта) дополнительно записывается ещё одна его копия. Работая с проектом, разработчик изменяет только файлы основной рабочей копии. Вторая локальная копия хранится в качестве эталона, позволяя в любой момент без обращения к серверу определить, какие изменения внесены в конкретный файл или проект в целом и от какой версии была «отпочкована» рабочая копия; как правило, любая попытка ручного изменения этой копии приводит к ошибкам в работе программного обеспечения VCS. (рис. 13)

![Рис. 13. Работа с общим хранилищем](/home/itmametkadihrov/SCR/13.JPG){ #fig:001 width=70% }

6.	Git поддерживает быстрое разделение и слияние версий, включает инструменты для визуализации и навигации по нелинейной истории разработки.
Удалённый доступ к репозиториям Git обеспечивается git-демоном, SSH- или HTTP-сервером. TCP-сервис git-daemon входит в дистрибутив Git и является наряду с SSH наиболее распространённым и надёжным методом доступа. Метод доступа по HTTP, несмотря на ряд ограничений, очень популярен в контролируемых сетях, потому что позволяет использовать существующие конфигурации сетевых фильтров.

7.	Наиболее часто используемые команды git:

– создание основного дерева репозитория:

git init

– получение обновлений (изменений) текущего дерева из центрального репозитория: 
git pull

– отправка всех произведённых изменений локального дерева в центральный репозиторий: 
git push

– просмотр списка изменённых файлов в текущей директории: 
git status

– просмотр текущих изменения: 
git diff

– сохранение текущих изменений:

– добавить все изменённые и/или созданные файлы и/или каталоги: 
git add .

– добавить конкретные изменённые и/или созданные файлы и/или каталоги: 
git add имена_файлов

– удалить файл и/или каталог из индекса репозитория (при этом файл и/или каталог
остаётся в локальной директории): 
git rm имена_файлов

– сохранение добавленных изменений:

– сохранить все добавленные изменения и все изменённые файлы: 
git commit -am 'Описание коммита'

– сохранить добавленные изменения с внесением комментария через встроенный редактор: 
git commit

– создание новой ветки, базирующейся на текущей: 
git checkout -b имя_ветки

– переключение на некоторую ветку: 
git checkout имя_ветки

(при переключении на ветку, которой ещё нет в локальном репозитории, она будет создана и связана с удалённой)

– отправка изменений конкретной ветки в центральный репозиторий: 
git push origin имя_ветки

– слияние ветки с текущим деревом: 
git merge --no-ff имя_ветки

– удаление ветки:

– удаление локальной уже слитой с основным деревом ветки: 
git branch -d имя_ветки

– принудительное удаление локальной ветки: 
git branch -D имя_ветки

– удаление ветки с центрального репозитория: 
git push origin :имя_ветки

8.	Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование: (рис. 14)

![Рис. 14. Запуск команды git clone](/home/itmametkadihrov/SCR/14.JPG){ #fig:001 width=70% }

Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит изменений. Добиться этого вы сможете запустив команду git add несколько раз, указав индексируемые файлы, а затем выполнив git commit: (рис. 15)

![Рис. 15. Добавление файлов](/home/itmametkadihrov/SCR/15.JPG){ #fig:001 width=70% }

9.	Ветвь - направление разработки, независимое от других. Ветвь представляет собой копию части хранилища, в которую можно вносить изменения, не влияющие на другие ветви. Документы в разных ветвях имеют одинаковую историю до точки ветвления и разные - после неё. Системы управления версиями предоставляют инструменты для манипуляции ветвями, прежде всего создание ветви и слияние изменений с другой ветвью.

10.	.gitignore - это простой текстовый файл, в каждой строке которого содержится шаблон файла или каталога, который необходимо проигнорировать.

.gitignore использует glob шаблоны для сопоставления имен файлов с символами подстановки. Если у вас есть файлы или каталоги, содержащие шаблон подстановки (например *), вы можете использовать один обратный слеш (\*), чтобы экранировать такой символ.
