
---
# Front matter
lang: ru-RU
title: "Лабораторная работа № 14"
subtitle: "Средства, применяемые при разработке программного обеспечения в ОС типа UNIX/Linux"
author: "Маметкадыров Ынтымак"

# Formatting
toc_depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4paper
documentclass: scrreprt
polyglossia-lang: russian
polyglossia-otherlangs: english
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase
indent: true
pdf-engine: lualatex
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобрести простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

# Выполнение лабораторной работы

1. В домашнем каталоге создали подкаталог ~/work/os/lab_prog (рис. 1).

![Рис. 1. Создание каталогов](/home/itmametkadihrov/Изображения/lab14/1.png){ #fig:001 width=70% }

2. Создали в нём файлы: calculate.h, calculate.c, main.c (рис. 2).

![Рис. 2. Создание файлов](/home/itmametkadihrov/Изображения/lab14/2.png){ #fig:001 width=70% }

3. Реализовали примитивнейший калькулятор (рис. 3), способный складывать, вычитать, умножать и делить, возводить число в степень, брать квадратный корень, вычислять sin, cos, tan. При запуске он будет запрашивать первое число, операцию, второе число. После этого программа выведет результат и остановится.

![](/home/itmametkadihrov/Изображения/lab14/3.png){ #fig:001 width=70% }

![Рис. 3. Создание файлов](/home/itmametkadihrov/Изображения/lab14/4.png){ #fig:001 width=70% }

4. Написали код для интерфейсного файла calculate.h, описывающий формат вызова функциикалькулятора (рис. 4).

![Рис. 4. Интерфейсный файл calculate.h](/home/itmametkadihrov/Изображения/lab14/5.png){ #fig:001 width=70% }

5. Написали код для основного файла main.c, реализующий интерфейс пользователя к калькулятору (рис. 5).

![Рис. 5. Основной файл main.c](/home/itmametkadihrov/Изображения/lab14/6.png){ #fig:001 width=70% }

6. Выполнили компиляцию программы посредством gcc (рис. 6).

![Рис. 6. Компиляция программы](/home/itmametkadihrov/Изображения/lab14/7.png){ #fig:001 width=70% }

7. Создали Makefile (рис. 7). Данный  файл  необходим  для  автоматической  компиляции  файлов calculate.c  (цель  calculate.o),  main.c  (цель  main.o),  а  также  их объединения  в  один  исполняемый  файл  calcul  (цель  calcul).  Цель clean  нужна  для  автоматического  удаления  файлов.  Переменная  CC отвечает  за  утилиту  для  компиляции.  Переменная  CFLAGS  отвечает за  опции  в  данной  утилите.  Переменная  LIBS  отвечает  за  опции  для объединения  объектных  файлов  в  один  исполняемый  файл. 

![Рис. 7. Makefile](/home/itmametkadihrov/Изображения/lab14/8.png){ #fig:001 width=70% }

8. В Makefile переменной CFLAGS присвоили опцию -g, для компиляции  объектных  файлов  и  их  использования  в  программе отладчика  GDB.  Сделали  так,  что  утилита  компиляции  выбирается  с помощью  переменной  CC (рис. 8). 

![Рис. 8. Новый Makefile](/home/itmametkadihrov/Изображения/lab14/9.png){ #fig:001 width=70% }

9. Запустили отладчик GDB, загрузив в него программу для отладки (рис. 9).

![Рис. 9. Отладчик GDB](/home/itmametkadihrov/Изображения/lab14/10.png){ #fig:001 width=70% }

10. Запустили программу внутри отладчика при помощи команды run (рис. 10).

![Рис. 10. Запуск программы внутри отладчика](/home/itmametkadihrov/Изображения/lab14/11.png){ #fig:001 width=70% }

11. Для постраничного просмотра исходного код использовали команду list (рис. 11).

![Рис. 11. Просмотр командой list](/home/itmametkadihrov/Изображения/lab14/12.png){ #fig:001 width=70% }

12. Для просмотра строк с 12 по 15 основного файла использовали list с параметрами 12 и 15 (рис. 12).

![Рис. 12. Просмотр командой list строк с 12 по 15](/home/itmametkadihrov/Изображения/lab14/13.png){ #fig:001 width=70% }

13. Для просмотра определённых строк не основного файла использовали list с параметрами calculate.c:20,29
 (рис. 13).

![Рис. 13. Просмотр командой list calculate.c:20,29](/home/itmametkadihrov/Изображения/lab14/14.png){ #fig:001 width=70% }

14. Установили точку останова в файле calculate.c на строке номер 21 (рис. 14).

![Рис. 14. Установка точки останова](/home/itmametkadihrov/Изображения/lab14/15.png){ #fig:001 width=70% }

15. Вывели информацию об имеющихся в проекте точка останова (рис. 15).

![Рис. 15. Точки останова](/home/itmametkadihrov/Изображения/lab14/16.png){ #fig:001 width=70% }

16. Запустили программу внутри отладчика и убедились, что программа остановится в момент прохождения точки останова (рис. 16).

![Рис. 16. Остановка в точке останова](/home/itmametkadihrov/Изображения/lab14/17.png){ #fig:001 width=70% }

17. Отладчик выдал следующую информацию:

	#0 Calculate (Numeral=5, Operation=0x7fffffffd280 "-") at calculate.c:21

	#1 0x0000000000400b2b in main () at main.c:17

	а команда backtrace показала весь стек вызываемых функций от начала программы до текущего места (рис. 16).

18. Посмотрели, чему равно на этом этапе значение переменной Numeral, введя print Numeral (рис. 17), на экран выведено число 5.

![Рис. 17. print Numeral](/home/itmametkadihrov/Изображения/lab14/18.png){ #fig:001 width=70% }

19. Сравнили  с  результатом  вывода  на  экран  после  использования команды  «display  Numeral». Значения  совпадают (рис. 17).

20. Убрали точки останова (рис. 18).

![Рис. 18. Удаление точек останова](/home/itmametkadihrov/Изображения/lab14/19.png){ #fig:001 width=70% }

21. С помощью утилиты splint попробовали проанализировать коды файлов calculate.c (рис. 20) и main.c (рис. 21). C  помощью  утилиты  splint  выяснилось,  что  в  файлах  calculate.c  и main.c  присутствует  функция  чтения  scanf,  возвращающая  целое число  (тип  int),  но  эти  числа  не  используются  и  нигде  не  сохранятся. Утилита  вывела  предупреждение  о  том,  что  в  файле  calculate.c происходит  сравнение  вещественного  числа  с  нулем.  Также возвращаемые  значения  (тип  double)  в  функциях  pow,  sqrt,  sin,  cos  и tan  записываются  в  переменную  типа  float,  что  свидетельствует  о потери  данных.

![Рис. 20. splint calculate.c](/home/itmametkadihrov/Изображения/lab14/20.png){ #fig:001 width=70% }

![Рис. 21. splint main.c](/home/itmametkadihrov/Изображения/lab14/21.png){ #fig:001 width=70% }

# Вывод

Приобрели простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

# Ответы на контрольные вопросы

1. Чтобы  получить  информацию  о возможностях  программ  gcc,  make,  gdb и  др.  нужно  воспользоваться  командой  man  или  опцией  -help  (-h)  для каждой  команды. 

2. Процесс разработки программного обеспечения обычно разделяется на следующие этапы:

	– планирование, включающее сбор и анализ требований к функционалу и другим характеристикам разрабатываемого приложения;

	– проектирование, включающее в себя разработку базовых алгоритмов и спецификаций, определение языка программирования;

	– непосредственная разработка приложения:

	– кодирование — по сути создание исходного текста программы (возможно в нескольких вариантах);

	– анализ разработанного кода;

	– сборка, компиляция и разработка исполняемого модуля;

	– тестирование и отладка, сохранение произведённых изменений;

	– документирование.

3. Для  имени  входного  файла  суффикс  определяет  какая  компиляция требуется.  Суффиксы  указывают  на  тип  объекта.  Файлы  с  расширением (суффиксом)  .c  воспринимаются  gcc  как  программы  на  языке  С,  файлы с  расширением  .cc  или  .C  −  как  файлы  на  языке  C++,  а  файлы  c расширением  .o  считаются  объектными.  Например,  в  команде  «gcc  -c main.c»:  gcc  по  расширению  (суффиксу)  .c  распознает  тип  файла  для компиляции  и  формирует  объектный  модуль  −  файл  с  расширением  .o. Если  требуется  получить  исполняемый  файл  с  определённым  именем (например,  hello),  то  требуется  воспользоваться  опцией  -o  и  в  качестве параметра задать  имя создаваемого  файла:  «gcc  -o  hello  main.c».

4. Основное  назначение  компилятора  языка  Си  в  UNIX  заключается  в компиляции  всей  программы  и  получении  исполняемого  файла/модуля.

5. Для  сборки  разрабатываемого  приложения  и  собственно  компиляции полезно воспользоваться утилитой make. Она  позволяет автоматизировать  процесс  преобразования  файлов  программы  из  одной формы в  другую,  отслеживает взаимосвязи  между  файлами.

6. Для  работы  с  утилитой  make  необходимо  в  корне  рабочего  каталога  с Вашим  проектом  создать  файл  с  названием  makefile  или  Makefile,  в котором  будут  описаны  правила  обработки  файлов  Вашего программного  комплекса.

	В самом  простом случае  Makefile  имеет  следующий  синтаксис:

	<цель_1> <цель_2>  ...  :  <зависимость_1> <зависимость_2> ...

	<команда  1>

	...

	<команда  n>

	Сначала  задаётся  список  целей,  разделённых  пробелами,  за  которым идёт  двоеточие  и  список  зависимостей.  Затем  в  следующих  строках указываются  команды.  Строки  с  командами  обязательно  должны начинаться  с табуляции.

	В  качестве  цели  в  Makefile  может  выступать  имя  файла  или  название какого-то  действия.  Зависимость  задаёт  исходные  параметры  (условия) для  достижения  указанной  цели.  Зависимость  также  может  быть названием  какого-то  действия.  Команды  −  собственно  действия, которые  необходимо  выполнить  для  достижения  цели.

	Общий  синтаксис  Makefile  имеет вид:

	target1  [target2...]:[:]  [dependment1...]

	[(tab)commands]  [#commentary]

	[(tab)commands]  [#commentary]

	Здесь  знак  #  определяет  начало  комментария  (содержимое  от  знака  #  и до  конца  строки  не  будет  обрабатываться.  Одинарное  двоеточие указывает  на  то,  что  последовательность  команд  должна  содержаться  в одной  строке.  Для  переноса  можно  в  длинной  строке  команд  можно использовать  обратный  слэш  (\).  Двойное  двоеточие  указывает  на  то, что  последовательность  команд  может  содержаться  в  нескольких последовательных  строках.

	Пример  более сложного  синтаксиса  Makefile:

	#

	#  Makefile  for  abcd.c

	#

	CC =  gcc

	CFLAGS  =

	#  Compile  abcd.c  normaly

	abcd:  abcd.c

		$(CC)  -o  abcd  $(CFLAGS) abcd.c
	clean:
		-rm  abcd  *.o  *~

	#  End  Makefile  for  abcd.c

	В  этом  примере  в  начале  файла  заданы  три  переменные:  CC  и  CFLAGS. Затем  указаны  цели,  их  зависимости  и  соответствующие  команды.  В командах  происходит  обращение  к  значениям  переменных.  Цель  с именем  clean  производит  очистку  каталога  от  файлов,  полученных  в результате  компиляции.  Для  её  описания  использованы  регулярные выражения. 

7. Во  время  работы  над  кодом  программы  программист  неизбежно сталкивается  с  появлением  ошибок  в  ней.  Использование  отладчика  для поиска  и  устранения ошибок  в программе  существенно облегчает  жизнь программиста.  В  комплект  программ  GNU  для  ОС  типа  UNIX  входит отладчик  GDB  (GNU  Debugger).

	Для  использования  GDB  необходимо  скомпилировать  анализируемый код  программы  таким  образом,  чтобы  отладочная  информация содержалась  в  результирующем  бинарном  файле.  Для  этого  следует воспользоваться  опцией  -g  компилятора  gcc:

	gcc  -c  file.c  -g

	После  этого  для  начала  работы  с  gdb  необходимо  в  командной  строке ввести  одноимённую  команду,  указав  в  качестве  аргумента анализируемый  бинарный  файл:

	gdb  file.o 

8. Основные  команды  отладчика  gdb:
	*  backtrace − вывод на экран пути к  текущей точке  останова  (по сути вывод  −  названий  всех  функций)

	*  break  −  установить  точку  останова (в  качестве параметра может быть  указан номер  строки  или  название  функции) 

	*  clear  −  удалить  все точки  останова в  функции 

	*  continue  −  продолжить  выполнение программы 

	*  delete  −  удалить  точку  останова 

	*  display  −  добавить  выражение  в  список  выражений,  значения которых  отображаются  при  достижении  точки  останова программы 

	*  finish  −  выполнить  программу  до  момента выхода  из  функции 

	*  info  breakpoints  −  вывести  на  экран  список  используемых  точек останова 

	*  info  watchpoints  −  вывести  на  экран  список  используемых контрольных  выражений 

	*  list  −  вывести  на  экран  исходный  код  (в  качестве  параметра  может быть указано  название  файла  и  через  двоеточие  номера  начальной и  конечной  строк) 

	*  next  −  выполнить  программу  пошагово,  но  без  выполнения вызываемых  в  программе  функций 

	*  print  −  вывести  значение  указываемого  в  качестве  параметра выражения 

	*  run − запуск программы на выполнение 

	*  set  − установить  новое значение переменной 

	*  step  −  пошаговое выполнение программы 

	*  watch  −  установить  контрольное  выражение,  при  изменении значения которого  программа  будет остановлена.

	Для  выхода  из  gdb  можно  воспользоваться  командой  quit  (или  её сокращённым  вариантом  q)  или  комбинацией  клавиш  Ctrl-d. Более  подробную  информацию  по  работе  с  gdb  можно  получить  с помощью  команд  gdb  -h  и  man  gdb.

9. Cхема отладки  программы  показана выше в настоящей лабораторной  работе. 

10. При первом запуске  компилятор  не  выдал  никаких  ошибок,  но  в  коде программы  main.c  допущена  ошибка,  которую  компилятор  мог пропустить  (возможно,  из-за  версии  8.3.0-19):  в  строке    scanf(“%s”,  &Operation); нужно  убрать  знак  &,  потому  что  имя  массива  символов  уже  является указателем  на первый  элемент  этого  массива. 

11. Система  разработки  приложений  UNIX  предоставляет  различные средства,  повышающие  понимание исходного  кода.  К ним  относятся:

	*  cscope −  исследование функций,  содержащихся в  программе, 

	*  lint  −  критическая проверка программ,  написанных  на языке  Си. 
12. Утилита  splint  анализирует  программный  код,  проверяет корректность  задания  аргументов  использованных  в  программе функций  и  типов  возвращаемых  значений,  обнаруживает синтаксические и семантические  ошибки.

	В  отличие  от  компилятора  C  анализатор  splint  генерирует  комментарии с  описанием  разбора  кода  программы  и  осуществляет  общий  контроль, обнаруживая  такие  ошибки,  как  одинаковые  объекты,  определённые  в разных  файлах,  или  объекты,  чьи  значения  не  используются  в  работе программы,  переменные  с  некорректно  заданными  значениями  и типами и  многое  другое. 










